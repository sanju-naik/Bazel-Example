// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.7.1 (swiftlang-5.7.1.135.2 clang-1400.0.29.51)
// swift-module-flags: -target arm64-apple-ios16.1 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name S4Core
// swift-module-flags-ignorable: -enable-bare-slash-regex
import Foundation
import LocalStorageInterface
@_exported import S4Core
import S4Protos
import Swift
import _Concurrency
import _StringProcessing
public class S4Manager {
  public init(analyticsManager: S4Core.AnalyticsManagerProtocol, config: S4Core.S4Config, baseUrl: Swift.String, networkManager: S4Core.NetworkManagerProtocol, fallbackToPollingManagerFactory: S4Core.FallbackToPollingManagerFactoryProtocol, s4Database database: LocalStorageInterface.LocalStorageInterface)
  public func startListeningForState(stateId: Swift.String)
  public func stopListeningForState(stateId: Swift.String)
  public func destroy()
  public func getCollectionData<M>(stateId: Swift.String, collectionName: Swift.String) -> [M]?
  public func addObserver(stateId: Swift.String?, collectionName: Swift.String, delegate: S4Core.S4DataHandlerProtocol)
  public func removeObserver(delegate: S4Core.S4DataHandlerProtocol, collectionName: Swift.String? = nil, stateId: Swift.String? = nil)
  @objc deinit
}
public protocol FallbackToPollingManagerFactoryProtocol {
  func createFallbackToPollingManager(stateId: Swift.String, topic: Swift.String, delegate: S4Core.FallbackToPollingManagerProtocolDelegate) -> S4Core.FallbackToPollingManagerProtocol
}
public protocol FallbackToPollingManagerProtocolDelegate : AnyObject {
  func onMessageReceived(_ message: S4Protos.S4_Gate_SyncResponse.OneOf_SyncResult)
  func onEventReceived(_ event: S4Core.S4Event)
  func getHTTPURL() -> Foundation.URL?
}
public protocol FallbackToPollingManagerProtocol {
  var delegate: S4Core.FallbackToPollingManagerProtocolDelegate? { get set }
  func start()
  func stop()
}
@objc @_inheritsConvenienceInitializers open class BaseAsyncOperation : Foundation.Operation {
  @objc override dynamic public var isAsynchronous: Swift.Bool {
    @objc get
  }
  @objc override dynamic public var isFinished: Swift.Bool {
    @objc get
  }
  @objc override dynamic public var isExecuting: Swift.Bool {
    @objc get
  }
  @objc override dynamic public init()
  @objc deinit
}
public struct S4Config {
  public let name: Swift.String
  public init(name: Swift.String)
}
public protocol NetworkManagerProtocol {
  func execute(url: Swift.String, method: Swift.String, params: [Swift.String : Any], completion: ((Swift.Int?, Swift.Result<Foundation.Data?, Swift.Error>) -> Swift.Void)?)
}
public enum S4Error : Swift.Error, Foundation.LocalizedError {
  case httpError(Swift.String)
  case decodingError
  case encodingError
  public var errorDescription: Swift.String {
    get
  }
  public var errorCode: Swift.Int {
    get
  }
  public var asNSError: Foundation.NSError {
    get
  }
}
@propertyWrapper final public class Atomic<T> {
  public init(_ value: T, dispatchQueueLabel: Swift.String = "atomic")
  final public var wrappedValue: T {
    get
    set
  }
  @objc deinit
}
public protocol AnalyticsManagerProtocol {
  func trackEvent(event: S4Core.S4Event)
}
public enum S4Event {
  case SyncApiFailureEvent(stateId: Swift.String, lastSyncedVersion: Swift.Int64?, forceRefresh: Swift.Bool, error: Swift.String)
  case SyncApiSuccessEvent(stateId: Swift.String, lastSyncedVersion: Swift.Int64?, forceRefresh: Swift.Bool)
  case S4DbSuccess(name: S4Core.DatabaseEvents, timeTaken: Swift.Int)
  case S4DbFailure(name: S4Core.DatabaseEvents, error: Swift.String)
  case S4PollingInterval(interval: Swift.String)
  case S4ParsingError(reason: Swift.String)
  case LocalStateUpdateEvent(stateId: Swift.String, lastSyncedVersion: Swift.Int64?, latestStateVersion: Swift.Int64)
  case S4UnsupportedMutation(stateId: Swift.String, mutationStateVersion: Swift.Int64, lastSyncedVersion: Swift.Int64?, mutationType: Swift.Int, channel: S4Core.Channel)
  case S4InvalidMutation(stateId: Swift.String, lastSyncedVersion: Swift.Int64?, mutationStateVersion: Swift.Int64, channel: S4Core.Channel)
  case SyncApiAttemptEvent(stateId: Swift.String, lastSyncedVersion: Swift.Int64?, forceRefresh: Swift.Bool)
  case S4StateSyncStartedEvent(stateId: Swift.String)
  case S4ObserveCollectionEvent(stateId: Swift.String?, collectionName: Swift.String)
  case S4DestroyedEvent
  case S4GetCollectionEvent(stateId: Swift.String, collectionName: Swift.String)
  case S4StateSyncStoppedEvent(stateId: Swift.String)
  case MutationReceivedEvent(stateId: Swift.String, lastSyncedVersion: Swift.Int64?, latestStateVersion: Swift.Int64, channel: S4Core.Channel)
  case SnapshotReceivedEvent(stateId: Swift.String, lastSyncedVersion: Swift.Int64?, latestStateVersion: Swift.Int64)
  case PollingEnabled(source: Swift.String)
  case PollingDisabled(source: Swift.String)
  case PollingError(error: Swift.String)
  case MessageReceived(channel: Swift.String)
  case FallbackPollingServiceStarted
  case FallbackPollingServiceStopped
  case S4EmptyMutation(stateId: Swift.String, lastSyncedVersion: Swift.Int64?, channel: S4Core.Channel)
  case CourierSubscriptionEvent(stateId: Swift.String)
  case CourierStreamError(error: Swift.String)
  case S4Init
  case S4Started
  case S4ObserverAdded(observer: Swift.String)
  case S4DataSentToObserver(collectionID: Swift.String)
  case S4CollectionFetched(collectionID: Swift.String)
  case S4Stopped
  case S4StateMismatch
}
public enum DatabaseEvents : Swift.String {
  case clearVersionTableSuccess
  case clearVersionTableFailure
  case upsertVersionSuccess
  case upsertVersionFailure
  case deleteDocumentSuccess
  case deletDocumentFailure
  case upsertDocumentSuccess
  case upsertDocumentFailure
  case storeSnapshotSuccess
  case storeSnapshotFailure
  case fetchDocumentSuccess
  case fetchDocumentFailure
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum Channel : Swift.String {
  case courier, http
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public protocol S4DataHandlerProtocol : AnyObject {
  associatedtype D
  func didReceiveServerEventsData(stateId: Swift.String, collectionName: Swift.String, data: [Self.D])
}
public protocol StreamManagerProtocol {
  func unsubscribe(topic: Swift.String)
  func subscribe(topic: Swift.String, source: Swift.String, qosValue: Swift.Int)
  var delegate: S4Core.StreamHandlerProtocol? { get set }
}
public protocol StreamHandlerProtocol {
  func handleServerEventWith(data: Foundation.Data)
}
public protocol MessageAdapter {
  func fromMessage<T>(_ message: Foundation.Data) throws -> T
}
public struct JSONAdapter : S4Core.MessageAdapter {
  public init(jsonDecoder: Foundation.JSONDecoder = JSONDecoder())
  public func fromMessage<T>(_ message: Foundation.Data) throws -> T
}
extension S4Core.DatabaseEvents : Swift.Equatable {}
extension S4Core.DatabaseEvents : Swift.Hashable {}
extension S4Core.DatabaseEvents : Swift.RawRepresentable {}
extension S4Core.Channel : Swift.Equatable {}
extension S4Core.Channel : Swift.Hashable {}
extension S4Core.Channel : Swift.RawRepresentable {}
